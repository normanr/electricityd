#!/usr/bin/python

__version__ = '3.4'

import BaseHTTPServer
import collections
import ast
import datetime
import gviz_api
import httplib
import json
import os
import Queue
import re
import serial
import SimpleHTTPServer
import socket
import SocketServer
import sys
import threading
import time
import traceback
import urllib2
import urlparse

if len(sys.argv) < 2:
    print >>sys.stderr, 'missing config filename'
    sys.exit(1)

with open(sys.argv[1]) as f:
    config = ast.literal_eval(f.read())

config_keys = ['xmlServerAddress', 'httpServerAddress', 'httpServerRoot', 'serialAddr',
               'serialBaud', 'serialTimeout', 'powerFailScript',
               'logFile', 'logTimeFormat', 'maxLogItems', 'services']
for key in config_keys:
    assert key in config, '%r not found in config' % key

if config['httpServerRoot']:
    os.chdir(config['httpServerRoot'])

clients = []
clients_lock = threading.Lock()
log = collections.deque([], config['maxLogItems'])
log_lock = threading.Lock()
RE_WATTS = re.compile('<ch1><watts>0*(?P<watts>\d+)</watts></ch1>')
RE_TEMP = re.compile('<tmpr> *(?P<temp>[\-\d.]+)</tmpr>')
RE_HIST = re.compile('<hist>.*<\/hist>');
RE_HIST_DATA = re.compile('<data><sensor>(?P<sensor>[^>]*)<\/sensor>(?P<data>.*?)<\/data>');
RE_HIST_VALUE = re.compile('<(?P<unit>[hdm])(?P<duration>[0-9]{3})>(?P<value>[^<]*)');

readings = {'lines': 0, 'temp': 0, 'watts': 0, 'joules': 0}
readings_lock = threading.Lock()
# key: duration (h/m/d), key: offset (numeric), value: 10 element list of float
history = collections.defaultdict(
    lambda: collections.defaultdict(
        lambda: [None] * 10)
    )
history_lock = threading.Lock()

def dumpLog(state):
    with log_lock, open(config['logFile'], 'a') as f:
        for ts, rd, line in log:
            print >>f, '%s %.1f %r' % (time.strftime(config['logTimeFormat'], time.localtime(ts)), rd, line)
        log.clear()
        print >>f, '%s %s' % (time.strftime(config['logTimeFormat']), state)

class serialMonitor(object):

    def __init__(self):
        self.serialPort = serial.serial_for_url(config['serialAddr'],
                                                baudrate=config['serialBaud'],
                                                timeout=config['serialTimeout'])
        self.timeLast = 0

    def sendToClients(self, data):
        with clients_lock:
            for client in clients:
                client.put(data)

    def parseLine(self, line):
            with readings_lock:
                readings['lines'] += 1
                match = RE_WATTS.search(line)
                if match:
                    timeNow = time.time()
                    if readings['watts']:
                        duration = timeNow - self.timeLast
                        readings['joules'] += readings['watts'] * duration
                    self.timeLast = timeNow
                    readings['watts'] = int(match.group('watts'))
                match = RE_TEMP.search(line)
                if match:
                    readings['temp'] = float(match.group('temp'))
            match = RE_HIST.search(line)
            if match:
                with history_lock:
                    for data in RE_HIST_DATA.finditer(match.group(0)):
                        sensor = int(data.group('sensor'))
                        for value in RE_HIST_VALUE.finditer(data.group('data')):
                            unit = value.group('unit')
                            duration = int(value.group('duration'), 10)
                            value = float(value.group('value'))
                            history[unit][duration][sensor] = value

    def watch(self):
        powerfail = False
        while True:
            timeStart = time.time()
            line = self.serialPort.readline()
            if line:
                timeEnd = time.time()
                readDuration = timeEnd - timeStart
                with log_lock:
                    log.append((timeEnd, readDuration, line))
                if powerfail:
                    powerfail = False
                    dumpLog('okay')
                    os.system(config['powerFailScript'] % 'okay')
                self.parseLine(line)
                self.sendToClients(line)
            else:
                if not powerfail:
                    powerfail = True
                    dumpLog('fail')
                    os.system(config['powerFailScript'] % 'fail')
                with readings_lock:
                    readings['watts'] = 0
                self.sendToClients('\r\n')

class serviceThread(threading.Thread):

    def __init__(self, name, settings):
        required_settings = ['url', 'interval']
        for key in required_settings:
            assert key in settings, '%r not found in %r service settings' % (key, name)
        assert settings['url'].format(**readings)
        if 'data' in settings:
            assert settings['data'].format(**readings)
        self.settings = settings

        threading.Thread.__init__(self, name=name)
        self.daemon = True
        self.start()

    def run(self):
        self.waitForFirstReading()
        self.sendReadings()

    def waitForFirstReading(self):
        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while True:
                queue.get()
                queue.task_done()
                with readings_lock:
                    if readings['watts']:
                        break
        finally:
            with clients_lock:
                clients.remove(queue)

    def sendReadings(self):
        timeStart = time.time()
        while True:
            try:
                self.sendSingleReading()
            except Exception as e:
                sendDuration = time.time() - timeStart
                msg = '%.1f %s %s' % (sendDuration, self.name, traceback.format_exc())
                print >>sys.stderr, msg
                dumpLog(msg)

            while timeStart < time.time():
                timeStart += self.settings['interval']
            time.sleep(max(timeStart - time.time(), 0))

    def sendSingleReading(self):
        url = self.settings['url'].format(**readings)
        kwargs = {
            'headers': {
                'User-Agent': 'Python-urllib/%s electricityd/%s' % (
                    urllib2.__version__, __version__)
            }
        }
        if 'data' in self.settings:
            kwargs['data'] = self.settings['data'].format(**readings)
        if 'headers' in self.settings:
            kwargs['headers'].update(self.settings['headers'])
        request = urllib2.Request(url, **kwargs)
        timeout = self.settings.get('timeout', 10)
        timeStart = time.time()
        try:
            response = urllib2.urlopen(request, timeout=timeout)
        except (httplib.HTTPException, socket.timeout, urllib2.URLError) as e:
            sendDuration = time.time() - timeStart
            msg = '%.1f %s %s.%s %s' % (
                sendDuration, self.name,
                e.__class__.__module__, e.__class__.__name__, e)
            print >>sys.stderr, msg
            dumpLog(msg)

class xmlSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        self.request.setblocking(0)

        with log_lock:
            local_log = list(log)
        for ts, d, data in local_log:
            self.request.send(data)

        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while True:
                data = queue.get()
                self.request.send(data)
                queue.task_done()
                try:
                    self.request.recv(1024)
                except socket.error as msg:
                    if msg[0] != 11: raise
        except socket.error as msg:
            pass
        finally:
            with clients_lock:
                clients.remove(queue)
            self.request.close()

class httpRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    wbufsize = -1  # http://lautaportti.wordpress.com/2011/04/01/basehttprequesthandler-wastes-tcp-packets/
    valid_constants = ['', '0']

    def version_string(self):
        return 'electricityd/%s %s' % (
            __version__,
            SimpleHTTPServer.SimpleHTTPRequestHandler.version_string(self))

    def do_GET(self): # on each client request
        try:
            url = urlparse.urlsplit(self.path)
            if config['httpServerRoot']:
                filename = self.translate_path(url.path)
                if os.path.isfile(filename) or filename == config['httpServerRoot']:
                    SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)
                    return
            if url.path == '/log':
                self.handleLogResponse(urlparse.parse_qs(url.query))
            elif url.path == '/hist.gviz':
                self.handleHistoryResponse(urlparse.parse_qs(url.query))
            else:
                self.handleVariableResponse(url.path)
        except Exception as e:
            self.send_error(500)
            msg = '%s %s %s' % (self.client_address, self.path, traceback.format_exc())
            print >>sys.stderr, msg
            dumpLog(msg)

    def list_directory(self, path):
        self.send_error(404, 'No permission to list directory')

    unit_map = {
        'h': ('hours', 1),
        'd': ('days', 1),
        'm': ('days', 30),
    }

    def handleHistoryResponse(self, query):
        try:
            unit = query.get('unit', '')[0]
        except IndexError:
            unit = ''

        try:
            tqx = query.get('tqx', '')[0]
        except IndexError:
            tqx = ''

        sensors = [int(x) for x in query.get('sensor', '')]

        convert = self.unit_map[unit]
        def mapTime(time):
            t = datetime.datetime.now()
            d = datetime.timedelta(**{convert[0]: time * convert[1]})
            return t - d

        def mapRow(row):
            return [row[s] for s in sensors]

        def mapTable(table):
            items = ([mapTime(k)] + mapRow(v) for k, v in table.iteritems())
            return sorted(items)

        with history_lock:
            data = {unit:mapTable(history[unit]) for unit in self.unit_map}

        if unit not in data:
            self.send_error(400, 'Invalid request')
            return

        schema = [('', 'datetime')]
        for sensor in sensors:
            schema.append(('Sensor %d' % sensor, 'number'))

        table = gviz_api.DataTable(schema)
        table.LoadData(data[unit])

        result = table.ToResponse(tqx=tqx)

        self.send_response(200, 'OK')
        self.send_header('Content-Type', 'application/json')
        self.send_header('Connection', 'close')
        self.end_headers()
        self.wfile.write(result + '\r\n')

    def handleLogResponse(self, query):
        try:
            ts = float(query.get('ts', '0')[0])
        except ValueError:
            ts = 0

        with log_lock:
            local_log = list(log)
        data = [x for x in local_log if x[0] > ts]

        if not data:
            queue = Queue.Queue()
            with clients_lock:
                clients.append(queue)
            try:
                queue.get(True, 30)
                queue.task_done()
            except Queue.Empty:
                pass
            finally:
                with clients_lock:
                    clients.remove(queue)

            with log_lock:
                local_log = list(log)
            data = [x for x in local_log if x[0] > ts]

        delay = 6
        if data:
            ts = data[-1][0]
            delay = ts - time.time() + 6

        result = json.dumps({
            'log': [x[2] for x in data],
            'ts': ts,
            'delay': delay,
        })

        self.send_response(200, 'OK')
        self.send_header('Content-Type', 'application/json')
        self.send_header('Connection', 'close')
        self.end_headers()
        self.wfile.write(result + '\r\n')

    def formatAsCsv(self, results):
        return 'text/csv', ','.join((v for k,v in results))

    def formatAsJson(self, results):
        return 'application/json', json.dumps(dict(results))

    def formatAsTxt(self, results):
        return 'text/plain', '\r\n'.join((v for k,v in results))

    def handleVariableResponse(self, path):
        if '.' not in path:
            self.send_error(400, 'Invalid request')
            return

        variables, fmt = path.lstrip('/').rsplit('.', 1)
        formatter = getattr(self, 'formatAs%s' % fmt.title(), None)
        if not formatter:
            self.send_error(400, 'Invalid format %s' % fmt)
            return

        variables = variables.split(',')
        with readings_lock:
            local_readings = readings.copy()
        results = []
        for variable in variables:
            if variable in self.valid_constants:
                results.append(variable)
                continue
            var_ops = variable.split('/')
            variable, ops = var_ops[0], var_ops[1:]
            if not variable in local_readings:
                self.send_error(400, 'Invalid variable %s' % variable)
                return
            value = local_readings[variable]
            for op in ops:
                if op == 'int':
                    value = int(value)
                else:
                    try:
                        if '.' in op:
                            value = value / float(op)
                        else:
                            value = value / int(op)
                    except (ValueError, ZeroDivisionError) as e:
                        self.send_error(400, 'Invalid op %s' % op)
                        return
            results.append(str(value))

        content_type, result = formatter(zip(variables, results))

        self.send_response(200, 'OK')
        self.send_header('Content-Type', content_type)
        self.send_header('Connection', 'close')
        self.end_headers()
        self.wfile.write(result + '\r\n')

class IPv6Mixin:
    address_family = socket.AF_INET6
    allow_reuse_address = True

class BackgroundMixin(SocketServer.ThreadingMixIn):
    daemon_threads = True

    def start(self):
        self.thread = threading.Thread(target=self.serve_forever,
                                       name=self.__class__.__name__)
        self.thread.daemon = True
        self.thread.start()

class BackgroundHTTP6Server(BackgroundMixin, IPv6Mixin, BaseHTTPServer.HTTPServer): pass
class BackgroundTCP6Server(BackgroundMixin, IPv6Mixin, SocketServer.TCPServer): pass

httpServer = BackgroundHTTP6Server(config['httpServerAddress'], httpRequestHandler)
httpServer.start()

xmlServer = BackgroundTCP6Server(config['xmlServerAddress'], xmlSocketHandler)
xmlServer.start()

services = []
for name, settings in config['services'].iteritems():
  if settings.get('enabled', True):
    services.append(serviceThread(name, settings))

serialMonitor().watch()
