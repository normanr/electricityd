#!/usr/bin/python

debug = 0
if not debug:
  mrtgElecServerAddress = '/var/run/electricity/socket'
  mrtgTempServerAddress = '/var/run/electricity/temp_socket'
  xmlServerAddress = ('',20222)
  pachubeServerAddress = ('',20080)
  powerFailScript = 'sudo -n /opt/etc/power/%s'
else:
  mrtgElecServerAddress = '/tmp/electricty_socket'
  mrtgTempServerAddress = '/tmp/temperature_socket'
  xmlServerAddress = ('',20223)
  pachubeServerAddress = ('',20081)
  powerFailScript = '/bin/echo %s'

serialAddr = '/dev/ttyUSB0'
serialBaud = 57600
serialTimeout = 90
maxLogItems = 10
logFile = '/var/log/electricity/log'

import atexit
import collections
import os
import Queue
import re
import signal
import serial
import socket
import SocketServer
import sys
import threading
import time

clients = []
clients_lock = threading.Lock()
log = collections.deque([], maxLogItems)
re_watts = re.compile('<ch1><watts>0*(\d+)</watts></ch1>')
re_temp = re.compile('<tmpr> *([\-\d.]+)</tmpr>')
pulseCounter = 0
watts = 0
joules = 0
temp = 0

def dumpLog(state):
    with open(logFile, 'a') as f:
        print >>f, '%.1f, %s:' % (time.time(), state)
        print >>f, '\n'.join(('%.1f, %.1f, %r' % x  for x in log))

def sendToClients(data):
    clients_lock.acquire()
    for client in clients:
        client.put(data)
    clients_lock.release()

def serialMonitor():
    global pulseCounter, watts, joules, temp
    serialPort = serial.Serial(serialAddr,serialBaud,timeout=serialTimeout)
    powerfail = False
    timeLast = 0

    while True:
        timeStart = time.time()
        line = serialPort.readline()
        readDuration = time.time() - timeStart
        log.append((timeStart, readDuration, line))
        if line:
            if powerfail:
                powerfail = False
                dumpLog('okay')
                os.system(powerFailScript % 'okay')
            pulseCounter += 1
            match = re_watts.search(line)
            if match:
                timeNow = time.time()
                if watts:
                    duration = timeNow - timeLast
                    joules += watts * duration
                timeLast = timeNow
                watts = int(match.group(1))
            match = re_temp.search(line)
            if match:
                temp = float(match.group(1))
            sendToClients(line)
        else:
            if not powerfail:
                powerfail = True
                dumpLog('fail')
                os.system(powerFailScript % 'fail')
            watts = 0
            sendToClients('\r\n')

def cleanup(signum=None, frame=None):
    if os.path.exists(mrtgElecServerAddress):
        os.remove(mrtgElecServerAddress)
    if os.path.exists(mrtgTempServerAddress):
        os.remove(mrtgTempServerAddress)
    sys.exit(0)

class mrtgElecSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        wattHours = str(int(joules / 3600))
        output = wattHours + '\n'
        output += '0\n'
        output += '\n'
        output += '\n'
        self.request.send(output)
        self.request.close()

class mrtgTempSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        self.request.send(str(int(temp)) + '\n')
        self.request.close()

class xmlSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        self.request.setblocking(0)
        queue = Queue.Queue()
        clients_lock.acquire()
        clients.append(queue)
        clients_lock.release()
        try:
            while 1:
                data = queue.get()
                self.request.send(data)
                queue.task_done()
                try:
                    self.request.recv(1024)
                except socket.error, msg:
                    if msg[0] != 11: raise
        except socket.error, msg:
	    pass
        finally:
            clients_lock.acquire()
            clients.remove(queue)
            clients_lock.release()
            self.request.close()

class pachubeSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        try:
            self.request.recv(1024)
        except socket.error, msg:
            return
        output = 'HTTP/1.0 200 OK\r\n'
        output += 'Content-Type: text/csv\r\n'
        output += '\r\n'
        output += str(temp) + ',' + str(watts) + '\r\n'
        self.request.send(output)
        self.request.close()

class ThreadingTCP6Server(SocketServer.ThreadingTCPServer):
    address_family = socket.AF_INET6
    allow_reuse_address = True

signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGTERM, cleanup)
atexit.register(cleanup)

mrtgElecServer = SocketServer.ThreadingUnixStreamServer(mrtgElecServerAddress, mrtgElecSocketHandler)
os.chmod(mrtgElecServerAddress, 0775)

mrtgElecThread = threading.Thread(None, mrtgElecServer.serve_forever)
mrtgElecThread.setDaemon(True)
mrtgElecThread.start()

mrtgTempServer = SocketServer.ThreadingUnixStreamServer(mrtgTempServerAddress, mrtgTempSocketHandler)
os.chmod(mrtgTempServerAddress, 0775)

mrtgTempThread = threading.Thread(None, mrtgTempServer.serve_forever)
mrtgTempThread.setDaemon(True)
mrtgTempThread.start()

pachubeServer = ThreadingTCP6Server(pachubeServerAddress, pachubeSocketHandler)
pachubeThread = threading.Thread(None, pachubeServer.serve_forever)
pachubeThread.setDaemon(True)
pachubeThread.start()

xmlServer = ThreadingTCP6Server(xmlServerAddress, xmlSocketHandler)
xmlThread = threading.Thread(None, xmlServer.serve_forever)
xmlThread.setDaemon(True)
xmlThread.start()

serialMonitor()
