#!/usr/bin/python

import BaseHTTPServer
import collections
import ast
import os
import Queue
import re
import serial
import socket
import SocketServer
import sys
import threading
import time
import traceback

if len(sys.argv) < 2:
  print 'missing config filename'
  sys.exit(1)

with open(sys.argv[1]) as f:
  config = ast.literal_eval(f.read())

config_keys = ['xmlServerAddress', 'httpServerAddress', 'powerFailScript',
               'logFile', 'serialAddr', 'serialBaud', 'serialTimeout',
               'maxLogItems']
for key in config_keys:
  locals()[key] = config[key]

clients = []
clients_lock = threading.Lock()
log = collections.deque([], maxLogItems)
re_watts = re.compile('<ch1><watts>0*(\d+)</watts></ch1>')
re_temp = re.compile('<tmpr> *([\-\d.]+)</tmpr>')
pulseCounter = 0
watts = 0
joules = 0
temp = 0

def dumpLog(state):
    with open(logFile, 'a') as f:
        print >>f, '\n'.join(('%.1f, %.1f, %r' % x  for x in log))
        print >>f, '%.1f, %s' % (time.time(), state)

def sendToClients(data):
    with clients_lock:
        for client in clients:
            client.put(data)

def serialMonitor():
    global pulseCounter, watts, joules, temp
    serialPort = serial.serial_for_url(serialAddr, serialBaud, timeout=serialTimeout)
    powerfail = False
    timeLast = 0

    while True:
        timeStart = time.time()
        line = serialPort.readline()
        readDuration = time.time() - timeStart
        log.append((timeStart, readDuration, line))
        if line:
            if powerfail:
                powerfail = False
                dumpLog('okay')
                os.system(powerFailScript % 'okay')
            pulseCounter += 1
            match = re_watts.search(line)
            if match:
                timeNow = time.time()
                if watts:
                    duration = timeNow - timeLast
                    joules += watts * duration
                timeLast = timeNow
                watts = int(match.group(1))
            match = re_temp.search(line)
            if match:
                temp = float(match.group(1))
            sendToClients(line)
        else:
            if not powerfail:
                powerfail = True
                dumpLog('fail')
                os.system(powerFailScript % 'fail')
            watts = 0
            sendToClients('\r\n')

class xmlSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        self.request.setblocking(0)
        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while 1:
                data = queue.get()
                self.request.send(data)
                queue.task_done()
                try:
                    self.request.recv(1024)
                except socket.error as msg:
                    if msg[0] != 11: raise
        except socket.error as msg:
            pass
        finally:
            with clients_lock:
                clients.remove(queue)
            self.request.close()

class httpRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    wbufsize = -1  # http://lautaportti.wordpress.com/2011/04/01/basehttprequesthandler-wastes-tcp-packets/
    valid_variables = ['temp', 'watts', 'joules']
    valid_constants = ['', '0']
    formats = {'csv':',', 'txt':'\r\n'}
    content_types = {'csv':'text/csv', 'txt': 'text/plain'}

    def version_string(self):
        return 'electricityd/3.1' + ' ' + BaseHTTPServer.BaseHTTPRequestHandler.version_string(self)

    def do_GET(self): # on each client request
        try:
            variables, fmt = self.path.lstrip('/').rsplit('.', 1)
            if fmt not in self.formats:
                return self.send_error(400, 'Invalid format %s' % fmt)

            variables = variables.split(',')
            results = []
            for variable in variables:
                if variable in self.valid_constants:
                    results.append(variable)
                    continue
                var_ops = variable.split('/')
                variable = var_ops[0]
                ops = var_ops[1:]
                if not variable in self.valid_variables:
                    return self.send_error(400, 'Invalid variable %s' % variable)
                if variable:
                    value = globals()[variable]
                    for op in ops:
                        if op == 'int':
                            value = int(value)
                        else:
                            try:
                                if '.' in op:
                                    value = value / float(op)
                                else:
                                    value = value / int(op)
                            except (ValueError, ZeroDivisionError) as e:
                                return self.send_error(400, 'Invalid op %s' % op)
                    results.append(str(value))
                else:
                    results.append('')


            result = self.formats[fmt].join(results)

            self.send_response(200, 'OK')
            self.send_header("Content-Type", self.content_types[fmt])
            self.send_header('Connection', 'close')
            self.end_headers()
            self.wfile.write(result + '\r\n')
        except Exception as e:
            self.send_error(500)
            traceback.print_exc()
            dumpLog('%s %s\n%s' % (self.client_address, self.path, traceback.format_exc()))

class ThreadingHTTP6Server(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    address_family = socket.AF_INET6
    allow_reuse_address = True
    daemon_threads = True

class ThreadingTCP6Server(SocketServer.ThreadingTCPServer):
    address_family = socket.AF_INET6
    allow_reuse_address = True
    daemon_threads = True

httpServer = ThreadingHTTP6Server(httpServerAddress, httpRequestHandler)
httpThread = threading.Thread(None, httpServer.serve_forever)
httpThread.daemon = True
httpThread.start()

xmlServer = ThreadingTCP6Server(xmlServerAddress, xmlSocketHandler)
xmlThread = threading.Thread(None, xmlServer.serve_forever)
xmlThread.daemon = True
xmlThread.start()

serialMonitor()
