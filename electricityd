#!/usr/bin/python

import BaseHTTPServer
import collections
import ast
import os
import Queue
import re
import serial
import socket
import SocketServer
import sys
import threading
import time
import traceback

if len(sys.argv) < 2:
    print 'missing config filename'
    sys.exit(1)

with open(sys.argv[1]) as f:
    config = ast.literal_eval(f.read())

config_keys = ['xmlServerAddress', 'httpServerAddress', 'powerFailScript',
               'logFile', 'serialAddr', 'serialBaud', 'serialTimeout',
               'maxLogItems']
for key in config_keys:
    assert key in config, '%r not found in config' % key

clients = []
clients_lock = threading.Lock()
log = collections.deque([], config['maxLogItems'])
RE_WATTS = re.compile('<ch1><watts>0*(?P<watts>\d+)</watts></ch1>')
RE_TEMP = re.compile('<tmpr> *(?P<temp>[\-\d.]+)</tmpr>')
readings = {'lines': 0, 'temp': 0, 'watts': 0, 'joules': 0}

def dumpLog(state):
    with open(config['logFile'], 'a') as f:
        print >>f, '\n'.join(('%.1f, %.1f, %r' % x  for x in log))
        print >>f, '%.1f, %s' % (time.time(), state)

def sendToClients(data):
    with clients_lock:
        for client in clients:
            client.put(data)

def serialMonitor():
    serialPort = serial.serial_for_url(config['serialAddr'],
                                       baudrate=config['serialBaud'],
                                       timeout=config['serialTimeout'])
    powerfail = False
    timeLast = 0

    while True:
        timeStart = time.time()
        line = serialPort.readline()
        readDuration = time.time() - timeStart
        log.append((timeStart, readDuration, line))
        if line:
            if powerfail:
                powerfail = False
                dumpLog('okay')
                os.system(config['powerFailScript'] % 'okay')
            readings['lines'] += 1
            match = RE_WATTS.search(line)
            if match:
                timeNow = time.time()
                if readings['watts']:
                    duration = timeNow - timeLast
                    readings['joules'] += readings['watts'] * duration
                timeLast = timeNow
                readings['watts'] = int(match.group('watts'))
            match = RE_TEMP.search(line)
            if match:
                readings['temp'] = float(match.group('temp'))
            sendToClients(line)
        else:
            if not powerfail:
                powerfail = True
                dumpLog('fail')
                os.system(config['powerFailScript'] % 'fail')
            readings['watts'] = 0
            sendToClients('\r\n')

class xmlSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        self.request.setblocking(0)
        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while 1:
                data = queue.get()
                self.request.send(data)
                queue.task_done()
                try:
                    self.request.recv(1024)
                except socket.error as msg:
                    if msg[0] != 11: raise
        except socket.error as msg:
            pass
        finally:
            with clients_lock:
                clients.remove(queue)
            self.request.close()

class httpRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    wbufsize = -1  # http://lautaportti.wordpress.com/2011/04/01/basehttprequesthandler-wastes-tcp-packets/
    valid_constants = ['', '0']
    formats = {'csv':',', 'txt':'\r\n'}
    content_types = {'csv':'text/csv', 'txt': 'text/plain'}

    def version_string(self):
        return 'electricityd/3.2 ' + BaseHTTPServer.BaseHTTPRequestHandler.version_string(self)

    def do_GET(self): # on each client request
        try:
            if '.' not in self.path:
                return self.send_error(400, 'Invalid request')

            variables, fmt = self.path.lstrip('/').rsplit('.', 1)
            if fmt not in self.formats:
                return self.send_error(400, 'Invalid format %s' % fmt)

            variables = variables.split(',')
            results = []
            for variable in variables:
                if variable in self.valid_constants:
                    results.append(variable)
                    continue
                var_ops = variable.split('/')
                variable, ops = var_ops[0], var_ops[1:]
                if not variable in readings:
                    return self.send_error(400, 'Invalid variable %s' % variable)
                value = readings[variable]
                for op in ops:
                    if op == 'int':
                        value = int(value)
                    else:
                        try:
                            if '.' in op:
                                value = value / float(op)
                            else:
                                value = value / int(op)
                        except (ValueError, ZeroDivisionError) as e:
                            return self.send_error(400, 'Invalid op %s' % op)
                results.append(str(value))

            result = self.formats[fmt].join(results)

            self.send_response(200, 'OK')
            self.send_header("Content-Type", self.content_types[fmt])
            self.send_header('Connection', 'close')
            self.end_headers()
            self.wfile.write(result + '\r\n')
        except Exception as e:
            self.send_error(500)
            traceback.print_exc()
            dumpLog('%s %s\n%s' % (self.client_address, self.path, traceback.format_exc()))

class IPv6Mixin:
    address_family = socket.AF_INET6
    allow_reuse_address = True

class BackgroundMixin(SocketServer.ThreadingMixIn):
    daemon_threads = True

    def start(self):
        self.thread = threading.Thread(target=self.serve_forever,
                                       name=self.__class__)
        self.thread.daemon = True
        self.thread.start()

class BackgroundHTTP6Server(BackgroundMixin, IPv6Mixin, BaseHTTPServer.HTTPServer): pass
class BackgroundTCP6Server(BackgroundMixin, IPv6Mixin, SocketServer.TCPServer): pass

httpServer = BackgroundHTTP6Server(config['httpServerAddress'], httpRequestHandler)
httpServer.start()

xmlServer = BackgroundTCP6Server(config['xmlServerAddress'], xmlSocketHandler)
xmlServer.start()

serialMonitor()
