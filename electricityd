#!/usr/bin/python

__version__ = '3.3'

import BaseHTTPServer
import collections
import ast
import httplib
import json
import os
import Queue
import re
import serial
import SimpleHTTPServer
import socket
import SocketServer
import sys
import threading
import time
import traceback
import urllib2
import urlparse

if len(sys.argv) < 2:
    print >>sys.stderr, 'missing config filename'
    sys.exit(1)

with open(sys.argv[1]) as f:
    config = ast.literal_eval(f.read())

config_keys = ['xmlServerAddress', 'httpServerAddress', 'httpServerRoot', 'serialAddr',
               'serialBaud', 'serialTimeout', 'powerFailScript',
               'logFile', 'logTimeFormat', 'maxLogItems', 'services']
for key in config_keys:
    assert key in config, '%r not found in config' % key

if config['httpServerRoot']:
    os.chdir(config['httpServerRoot'])

clients = []
clients_lock = threading.Lock()
log = collections.deque([], config['maxLogItems'])
log_lock = threading.Lock()
RE_WATTS = re.compile('<ch1><watts>0*(?P<watts>\d+)</watts></ch1>')
RE_TEMP = re.compile('<tmpr> *(?P<temp>[\-\d.]+)</tmpr>')
readings = {'lines': 0, 'temp': 0, 'watts': 0, 'joules': 0}
readings_lock = threading.Lock()

def dumpLog(state):
    with log_lock, open(config['logFile'], 'a') as f:
        for ts, rd, line in log:
            print >>f, '%s %.1f %r' % (time.strftime(config['logTimeFormat'], time.localtime(ts)), rd, line)
        log.clear()
        print >>f, '%s %s' % (time.strftime(config['logTimeFormat']), state)

def sendToClients(data):
    with clients_lock:
        for client in clients:
            client.put(data)

def serialMonitor():
    serialPort = serial.serial_for_url(config['serialAddr'],
                                       baudrate=config['serialBaud'],
                                       timeout=config['serialTimeout'])
    powerfail = False
    timeLast = 0

    while True:
        timeStart = time.time()
        line = serialPort.readline()
        readDuration = time.time() - timeStart
        with log_lock:
            log.append((timeStart, readDuration, line))
        if line:
            if powerfail:
                powerfail = False
                dumpLog('okay')
                os.system(config['powerFailScript'] % 'okay')
            with readings_lock:
                readings['lines'] += 1
                match = RE_WATTS.search(line)
                if match:
                    timeNow = time.time()
                    if readings['watts']:
                        duration = timeNow - timeLast
                        readings['joules'] += readings['watts'] * duration
                    timeLast = timeNow
                    readings['watts'] = int(match.group('watts'))
                match = RE_TEMP.search(line)
                if match:
                    readings['temp'] = float(match.group('temp'))
            sendToClients(line)
        else:
            if not powerfail:
                powerfail = True
                dumpLog('fail')
                os.system(config['powerFailScript'] % 'fail')
            with readings_lock:
                readings['watts'] = 0
            sendToClients('\r\n')

class serviceThread(threading.Thread):

    def __init__(self, name, settings):
        required_settings = ['url', 'interval']
        for key in required_settings:
            assert key in settings, '%r not found in %r service settings' % (key, name)
        assert settings['url'].format(**readings)
        if 'data' in settings:
            assert settings['data'].format(**readings)
        self.settings = settings

        threading.Thread.__init__(self, name=name)
        self.daemon = True
        self.start()

    def run(self):
        self.waitForFirstReading()
        self.sendReadings()

    def waitForFirstReading(self):
        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while True:
                queue.get()
                queue.task_done()
                with readings_lock:
                    if readings['watts']:
                        break
        finally:
            with clients_lock:
                clients.remove(queue)

    def sendReadings(self):
        timeStart = time.time()
        while True:
            try:
                self.sendSingleReading()
            except Exception as e:
                sendDuration = time.time() - timeStart
                msg = '%.1f %s %s' % (sendDuration, self.name, traceback.format_exc())
                print >>sys.stderr, msg
                dumpLog(msg)

            while timeStart < time.time():
                timeStart += self.settings['interval']
            time.sleep(max(timeStart - time.time(), 0))

    def sendSingleReading(self):
        url = self.settings['url'].format(**readings)
        kwargs = {
            'headers': {
                'User-Agent': 'Python-urllib/%s electricityd/%s' % (
                    urllib2.__version__, __version__)
            }
        }
        if 'data' in self.settings:
            kwargs['data'] = self.settings['data'].format(**readings)
        if 'headers' in self.settings:
            kwargs['headers'].update(self.settings['headers'])
        request = urllib2.Request(url, **kwargs)
        timeout = self.settings.get('timeout', 10)
        timeStart = time.time()
        try:
            response = urllib2.urlopen(request, timeout=timeout)
        except (httplib.HTTPException, socket.timeout, urllib2.URLError) as e:
            sendDuration = time.time() - timeStart
            msg = '%.1f %s %s.%s %s' % (
                sendDuration, self.name,
                e.__class__.__module__, e.__class__.__name__, e)
            print >>sys.stderr, msg
            dumpLog(msg)

class xmlSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        self.request.setblocking(0)
        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while True:
                data = queue.get()
                self.request.send(data)
                queue.task_done()
                try:
                    self.request.recv(1024)
                except socket.error as msg:
                    if msg[0] != 11: raise
        except socket.error as msg:
            pass
        finally:
            with clients_lock:
                clients.remove(queue)
            self.request.close()

class httpRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    wbufsize = -1  # http://lautaportti.wordpress.com/2011/04/01/basehttprequesthandler-wastes-tcp-packets/
    valid_constants = ['', '0']

    def version_string(self):
        return 'electricityd/%s %s' % (
            __version__,
            SimpleHTTPServer.SimpleHTTPRequestHandler.version_string(self))

    def do_GET(self): # on each client request
        try:
            url = urlparse.urlsplit(self.path)
            if config['httpServerRoot']:
                filename = self.translate_path(url.path)
                if os.path.isfile(filename) or filename == config['httpServerRoot']:
                    SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)
                    return
            if url.path == '/log':
                self.handleLogResponse(urlparse.parse_qs(url.query))
            else:
                self.handleVariableResponse(url.path)
        except Exception as e:
            self.send_error(500)
            msg = '%s %s %s' % (self.client_address, self.path, traceback.format_exc())
            print >>sys.stderr, msg
            dumpLog(msg)

    def list_directory(self, path):
        self.send_error(404, 'No permission to list directory')

    def handleLogResponse(self, query):
        try:
            ts = float(query.get('ts', '0')[0])
        except ValueError:
            ts = 0

        with log_lock:
            local_log = list(log)
        data = [x for x in local_log if x[0] > ts]

        if not data:
            queue = Queue.Queue()
            with clients_lock:
                clients.append(queue)
            try:
                queue.get(True, 30)
                queue.task_done()
            except Queue.Empty:
                pass
            finally:
                with clients_lock:
                    clients.remove(queue)

        with log_lock:
            local_log = list(log)
        data = [x for x in local_log if x[0] > ts]

        result = json.dumps({
            'log': data,
            'now': time.time(),
        })

        self.send_response(200, 'OK')
        self.send_header('Content-Type', 'application/json')
        self.send_header('Connection', 'close')
        self.end_headers()
        self.wfile.write(result + '\r\n')

    def formatAsCsv(self, results):
        return 'text/csv', ','.join((v for k,v in results))

    def formatAsJson(self, results):
        return 'application/json', json.dumps(dict(results))

    def formatAsTxt(self, results):
        return 'text/plain', '\r\n'.join((v for k,v in results))

    def handleVariableResponse(self, path):
        if '.' not in path:
            self.send_error(400, 'Invalid request')
            return

        variables, fmt = path.lstrip('/').rsplit('.', 1)
        formatter = getattr(self, 'formatAs%s' % fmt.title(), None)
        if not formatter:
            self.send_error(400, 'Invalid format %s' % fmt)
            return

        variables = variables.split(',')
        with readings_lock:
            local_readings = readings.copy()
        results = []
        for variable in variables:
            if variable in self.valid_constants:
                results.append(variable)
                continue
            var_ops = variable.split('/')
            variable, ops = var_ops[0], var_ops[1:]
            if not variable in local_readings:
                self.send_error(400, 'Invalid variable %s' % variable)
                return
            value = local_readings[variable]
            for op in ops:
                if op == 'int':
                    value = int(value)
                else:
                    try:
                        if '.' in op:
                            value = value / float(op)
                        else:
                            value = value / int(op)
                    except (ValueError, ZeroDivisionError) as e:
                        self.send_error(400, 'Invalid op %s' % op)
                        return
            results.append(str(value))

        content_type, result = formatter(zip(variables, results))

        self.send_response(200, 'OK')
        self.send_header('Content-Type', content_type)
        self.send_header('Connection', 'close')
        self.end_headers()
        self.wfile.write(result + '\r\n')

class IPv6Mixin:
    address_family = socket.AF_INET6
    allow_reuse_address = True

class BackgroundMixin(SocketServer.ThreadingMixIn):
    daemon_threads = True

    def start(self):
        self.thread = threading.Thread(target=self.serve_forever,
                                       name=self.__class__.__name__)
        self.thread.daemon = True
        self.thread.start()

class BackgroundHTTP6Server(BackgroundMixin, IPv6Mixin, BaseHTTPServer.HTTPServer): pass
class BackgroundTCP6Server(BackgroundMixin, IPv6Mixin, SocketServer.TCPServer): pass

httpServer = BackgroundHTTP6Server(config['httpServerAddress'], httpRequestHandler)
httpServer.start()

xmlServer = BackgroundTCP6Server(config['xmlServerAddress'], xmlSocketHandler)
xmlServer.start()

services = []
for name, settings in config['services'].iteritems():
  if settings.get('enabled', True):
    services.append(serviceThread(name, settings))

serialMonitor()
