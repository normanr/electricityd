#!/usr/bin/python

__version__ = '3.3'

import BaseHTTPServer
import collections
import ast
import os
import Queue
import re
import serial
import socket
import SocketServer
import sys
import threading
import time
import traceback
import urllib2

if len(sys.argv) < 2:
    print >>sys.stderr, 'missing config filename'
    sys.exit(1)

with open(sys.argv[1]) as f:
    config = ast.literal_eval(f.read())

config_keys = ['xmlServerAddress', 'httpServerAddress', 'serialAddr',
               'serialBaud', 'serialTimeout', 'powerFailScript',
               'logFile', 'logTimeFormat', 'maxLogItems', 'services']
for key in config_keys:
    assert key in config, '%r not found in config' % key

clients = []
clients_lock = threading.Lock()
log = collections.deque([], config['maxLogItems'])
log_lock = threading.Lock()
RE_WATTS = re.compile('<ch1><watts>0*(?P<watts>\d+)</watts></ch1>')
RE_TEMP = re.compile('<tmpr> *(?P<temp>[\-\d.]+)</tmpr>')
readings = {'lines': 0, 'temp': 0, 'watts': 0, 'joules': 0}
readings_lock = threading.Lock()

def dumpLog(state):
    with log_lock, open(config['logFile'], 'a') as f:
        for ts, rd, line in log:
            print >>f, '%s %.1f %r' % (time.strftime(config['logTimeFormat'], time.localtime(ts)), rd, line)
        log.clear()
        print >>f, '%s %s' % (time.strftime(config['logTimeFormat']), state)

def sendToClients(data):
    with clients_lock:
        for client in clients:
            client.put(data)

def serialMonitor():
    serialPort = serial.serial_for_url(config['serialAddr'],
                                       baudrate=config['serialBaud'],
                                       timeout=config['serialTimeout'])
    powerfail = False
    timeLast = 0

    while True:
        timeStart = time.time()
        line = serialPort.readline()
        readDuration = time.time() - timeStart
        with log_lock:
            log.append((timeStart, readDuration, line))
        if line:
            if powerfail:
                powerfail = False
                dumpLog('okay')
                os.system(config['powerFailScript'] % 'okay')
            with readings_lock:
                readings['lines'] += 1
                match = RE_WATTS.search(line)
                if match:
                    timeNow = time.time()
                    if readings['watts']:
                        duration = timeNow - timeLast
                        readings['joules'] += readings['watts'] * duration
                    timeLast = timeNow
                    readings['watts'] = int(match.group('watts'))
                match = RE_TEMP.search(line)
                if match:
                    readings['temp'] = float(match.group('temp'))
            sendToClients(line)
        else:
            if not powerfail:
                powerfail = True
                dumpLog('fail')
                os.system(config['powerFailScript'] % 'fail')
            with readings_lock:
                readings['watts'] = 0
            sendToClients('\r\n')

class serviceThread(threading.Thread):

    def __init__(self, name, settings):
        required_settings = ['url', 'interval']
        for key in required_settings:
            assert key in settings, '%r not found in %r service settings' % (key, name)
        assert settings['url'].format(**readings)
        if 'data' in settings:
            assert settings['data'].format(**readings)
        self.settings = settings

        threading.Thread.__init__(self, name=name)
        self.daemon = True
        self.start()

    def run(self):
        self.waitForFirstReading()
        self.sendReadings()

    def waitForFirstReading(self):
        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while True:
                queue.get()
                queue.task_done()
                with readings_lock:
                    if readings['watts']:
                        break
        finally:
            with clients_lock:
                clients.remove(queue)

    def sendReadings(self):
        timeStart = time.time()
        while True:
            try:
                self.sendSingleReading()
            except urllib2.URLError as e:
                sendDuration = time.time() - timeStart
                msg = '%.1f %s %s' % (sendDuration, self.name, e)
                print >>sys.stderr, msg
                dumpLog(msg)
            except Exception as e:
                sendDuration = time.time() - timeStart
                msg = '%.1f %s %s' % (sendDuration, self.name, traceback.format_exc())
                print >>sys.stderr, msg
                dumpLog(msg)

            while timeStart < time.time():
                timeStart += self.settings['interval']
            time.sleep(max(timeStart - time.time(), 0))

    def sendSingleReading(self):
        url = self.settings['url'].format(**readings)
        kwargs = {
            'headers': {
                'User-Agent': 'Python-urllib/%s electricityd/%s' % (
                    urllib2.__version__, __version__)
            }
        }
        if 'data' in self.settings:
            kwargs['data'] = self.settings['data'].format(**readings)
        if 'headers' in self.settings:
            kwargs['headers'].update(self.settings['headers'])
        request = urllib2.Request(url, **kwargs)
        timeout = self.settings.get('timeout', 10)
        response = urllib2.urlopen(request, timeout=timeout)

class xmlSocketHandler(SocketServer.BaseRequestHandler):
    def handle(self): # on each client connect
        self.request.setblocking(0)
        queue = Queue.Queue()
        with clients_lock:
            clients.append(queue)
        try:
            while True:
                data = queue.get()
                self.request.send(data)
                queue.task_done()
                try:
                    self.request.recv(1024)
                except socket.error as msg:
                    if msg[0] != 11: raise
        except socket.error as msg:
            pass
        finally:
            with clients_lock:
                clients.remove(queue)
            self.request.close()

class httpRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    wbufsize = -1  # http://lautaportti.wordpress.com/2011/04/01/basehttprequesthandler-wastes-tcp-packets/
    valid_constants = ['', '0']
    formats = {'csv':',', 'txt':'\r\n'}
    content_types = {'csv':'text/csv', 'txt': 'text/plain'}

    def version_string(self):
        return 'electricityd/%s %s' % (
            __version__,
            BaseHTTPServer.BaseHTTPRequestHandler.version_string(self))

    def do_GET(self): # on each client request
        try:
            if '.' not in self.path:
                return self.send_error(400, 'Invalid request')

            variables, fmt = self.path.lstrip('/').rsplit('.', 1)
            if fmt not in self.formats:
                return self.send_error(400, 'Invalid format %s' % fmt)

            variables = variables.split(',')
            results = []
            for variable in variables:
                if variable in self.valid_constants:
                    results.append(variable)
                    continue
                var_ops = variable.split('/')
                variable, ops = var_ops[0], var_ops[1:]
                with readings_lock:
                    if not variable in readings:
                        return self.send_error(400, 'Invalid variable %s' % variable)
                    value = readings[variable]
                for op in ops:
                    if op == 'int':
                        value = int(value)
                    else:
                        try:
                            if '.' in op:
                                value = value / float(op)
                            else:
                                value = value / int(op)
                        except (ValueError, ZeroDivisionError) as e:
                            return self.send_error(400, 'Invalid op %s' % op)
                results.append(str(value))

            result = self.formats[fmt].join(results)

            self.send_response(200, 'OK')
            self.send_header("Content-Type", self.content_types[fmt])
            self.send_header('Connection', 'close')
            self.end_headers()
            self.wfile.write(result + '\r\n')
        except Exception as e:
            self.send_error(500)
            msg = '%s %s %s' % (self.client_address, self.path, traceback.format_exc())
            print >>sys.stderr, msg
            dumpLog(msg)

class IPv6Mixin:
    address_family = socket.AF_INET6
    allow_reuse_address = True

class BackgroundMixin(SocketServer.ThreadingMixIn):
    daemon_threads = True

    def start(self):
        self.thread = threading.Thread(target=self.serve_forever,
                                       name=self.__class__.__name__)
        self.thread.daemon = True
        self.thread.start()

class BackgroundHTTP6Server(BackgroundMixin, IPv6Mixin, BaseHTTPServer.HTTPServer): pass
class BackgroundTCP6Server(BackgroundMixin, IPv6Mixin, SocketServer.TCPServer): pass

httpServer = BackgroundHTTP6Server(config['httpServerAddress'], httpRequestHandler)
httpServer.start()

xmlServer = BackgroundTCP6Server(config['xmlServerAddress'], xmlSocketHandler)
xmlServer.start()

services = []
for name, settings in config['services'].iteritems():
  if settings.get('enabled', True):
    services.append(serviceThread(name, settings))

serialMonitor()
